## Type Hint Declaration
You can declare all the standard Python types:
+ int
+ float
+ bool
+ bytes

and some data structures that can contain other values (generic types):
+ list
+ dict
+ set
+ tuple

The syntax using typing is compatible with all versions, from Python 3.6.

**Examples**

+ Variable to be a list of str: `my_list: list[str]`
+ variable is a tuple with 3 items, an int, another int, and a str: `my_tuple: tuple[int, int, str]`
+ Variable is a set, and each of its items is of type bytes: `my_set: set[bytes]`
+ To define a dict, you pass 2 type parameters, separated by commas: `my_dict: dict[str, float]`
+ You can declare that a variable can be any of several types, for example, an int or a str: `item: Union[int, str]`
+ You can declare that a value could have a type, like str, but that it could also be None: `name: Optional[str] = None`. `Optional[Something]` is actually a shortcut for `Union[Something, None]`, they are equivalent. Clear alternative: `name: Union[str, None] = None`

## Typer: simple example

```python
import typer


def main(name: str, lastname: str = "", formal: bool = False):
    """
    Say hi to NAME, optionally with a --lastname.

    If --formal is used, say hi very formally.
    """
    if formal:
        print(f"Good day Ms. {name} {lastname}.")
    else:
        print(f"Hello {name} {lastname}")


if __name__ == "__main__":
    typer.run(main)
```

## Rich Markup

**Text display**
```python
import typer
from rich import print

data = {
    "name": "Rick",
    "age": 42,
    "items": [{"name": "Portal Gun"}, {"name": "Plumbus"}],
    "active": True,
    "affiliation": None,
}


def main():
    print("Here's the data")
    print(data)


if __name__ == "__main__":
    typer.run(main)
```

**Table display**
```python
import typer
from rich.console import Console
from rich.table import Table

console = Console()


def main():
    table = Table("Name", "Item")
    table.add_row("Rick", "Portal Gun")
    table.add_row("Morty", "Plumbus")
    console.print(table)


if __name__ == "__main__":
    typer.run(main)
```

## Typer: Exit

**Simple program exit**


```python
import typer

existing_usernames = ["rick", "morty"]


def maybe_create_user(username: str):
    if username in existing_usernames:
        print("The user already exists")
        raise typer.Exit()
    else:
        print(f"User created: {username}")


def send_new_user_notification(username: str):
    # Somehow send a notification here for the new user, maybe an email
    print(f"Notification sent for new user: {username}")


def main(username: str):
    maybe_create_user(username=username)
    send_new_user_notification(username=username)


if __name__ == "__main__":
    typer.run(main)
```

**Exit with code**

```python
import typer


def main(username: str):
    if username == "root":
        print("The root user is reserved")
        raise typer.Exit(code=1)
    print(f"New user created: {username}")


if __name__ == "__main__":
    typer.run(main)
```
Print the result code of the last program executed
`echo $?`. `True` means success, `False` means failure.

## Typer: Abort

```python
import typer


def main(username: str):
    if username == "root":
        print("The root user is reserved")
        raise typer.Abort()
    print(f"New user created: {username}")


if __name__ == "__main__":
    typer.run(main)
```
Works more or less the same as typer.Exit() but will print "Aborted!" to the screen.

## Typer: Annotated

```python
import typer
from typing_extensions import Annotated


# def main(name: Annotated[str, typer.Argument()] = "World"):
def main(name: Annotated[str, typer.Argument()]):
    print(f"Hello {name}!")


if __name__ == "__main__":
    typer.run(main)
```

Example of using `Annotated` to define optional or required function argument.

## Typer: Dynamic default value

```python
import random

import typer
from typing_extensions import Annotated


def get_name():
    return random.choice(["Deadpool", "Rick", "Morty", "Hiro"])


def main(name: Annotated[str, typer.Argument(default_factory=get_name)]):
    print(f"Hello {name}")


if __name__ == "__main__":
    typer.run(main)
```
Make the default value be dynamically generated by passing a function as the default_factory argument:

## Typer: Argument help

```python
import typer
from typing_extensions import Annotated


def main(name: Annotated[str, typer.Argument(help="The name of the user to greet")]):
    print(f"Hello {name}")


if __name__ == "__main__":
    typer.run(main)
```
## Typer: Combine help text and docstrings

```python
import typer
from typing_extensions import Annotated


def main(name: Annotated[str, typer.Argument(help="The name of the user to greet")]):
    """
    Say hi to NAME very gently, like Dirk.
    """
    print(f"Hello {name}")


if __name__ == "__main__":
    typer.run(main)
```

